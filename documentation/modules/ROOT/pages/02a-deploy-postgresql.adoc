= Spring Boot Inner-loop Development Iteration Using PostgreSQL
include::_attributes.adoc[]

The main objective of this lab is to guide you through the cycle of developing cloud native applications stressing on the inner-loop, that is all the activities a developer so in his/her computer before actually pushing code to the repository.

In this particular case we have a Spring Boot CRUD application, so Java code and a database. Which database? Well we have decided to use *H2* for quick prototyping then *PostgreSQL* or *Oracle* once the code is deployed.

[#the-code]
== The code

This simple service implements a CRUD interface for the `FRUIT` table. To do so, it uses JPA annotations like `@Entity`, `@Id`, etc. You can find the Java code of the JPA entity below.

NOTE: In order to make the code more portable we have annotated the `id` attribute so that the value is generated using a sequence named `FRUIT_SEQ`. 

[.lines_7]
[.console-input]
[source, java,subs="+macros,+attributes"]
----
@Entity
public class Fruit {

    @Id
    @GeneratedValue(strategy = GenerationType.SEQUENCE, generator = "FruitSequence")
    @SequenceGenerator(name = "FruitSequence", sequenceName = "FRUIT_SEQ")
    private Integer id;

    private String name;

    public Fruit() {
    }

    public Fruit(String type) {
        this.name = type;
    }

    public Integer getId() {
        return id;
    }

    public void setId(Integer id) {
        this.id = id;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }
}
----

The actual service is implemented in class `FruitController` find below a simplified version of the code. Nothing complicated here.

[.lines_7]
[.console-input]
[source, java,subs="+macros,+attributes"]
----
@RestController
@RequestMapping(value = "/api/fruits")
public class FruitController {

    private final FruitRepository repository;

    public FruitController(FruitRepository repository) {
        this.repository = repository;
    }

    @GetMapping("/{id}")
    public Fruit get(@PathVariable("id") Integer id) {
        ...
        return repository.findById(id).get();
    }

    @GetMapping
    public List<Fruit> getAll() {
        ...
        return StreamSupport
                .stream(fruits, false)
                .collect(Collectors.toList());
    }

    @ResponseStatus(HttpStatus.CREATED)
    @PostMapping
    public Fruit post(@RequestBody(required = false) Fruit fruit) {
        ...
        return repository.save(fruit);
    }

    ...
}
----

Time to get our hands dirty. Clone or download the code, your choice.

[tabs]
====
Clone the code::
+
[.console-input]
[source,bash,subs="attributes+"]
--
git clone {git_url}
--
Download the code::
+
[.console-input]
[source,bash,subs="attributes+"]
--
curl -OL {download_url}
--
====

[#maven-profiles]
== Maven Profiles

As we stated at the begging we want to use different databases, *H2* to develop quickcly then either *PostgreSQL* or *Oracle* once the code is deployed in OpenShift. In order to do so we have defined 3 profiles:

* *local* for H2
* *openshift-postgresql* for PostgreSQL
* *openshift-oracle* for Oracle

[tabs]
====
local::
+
[.console-input]
[source,properties,subs="attributes+"]
--
# H2 settings
spring.datasource.url=jdbc:h2:mem:testdb
spring.datasource.driverClassName=org.h2.Driver
spring.datasource.driver-class-name=org.h2.Driver
spring.datasource.username=sa
spring.datasource.password=password
spring.datasource.platform=h2

spring.jpa.properties.hibernate.hbm2ddl.import_files=import-h2.sql
spring.jpa.database-platform=org.hibernate.dialect.H2Dialect
spring.jpa.hibernate.ddl-auto=create
--
openshift-postgresql::
+
[.console-input]
[source,properties,subs="attributes+"]
--
# PostgreSQL settings
spring.datasource.url=jdbc:postgresql://${SERVICE_DB_HOST}:5432/${SERVICE_DB_NAME}
spring.datasource.username=${SERVICE_DB_USER}
spring.datasource.password=${SERVICE_DB_PASSWORD}
spring.datasource.driver-class-name=org.postgresql.Driver
spring.datasource.platform=postgresql

spring.jpa.properties.hibernate.hbm2ddl.import_files=import-postgresql.sql
spring.jpa.database-platform=org.hibernate.dialect.PostgreSQLDialect
spring.jpa.hibernate.ddl-auto=create

## To avoid CLOB related error...
spring.jpa.properties.hibernate.jdbc.lob.non_contextual_creation=true
--
openshift-oracle::
+
[.console-input]
[source,properties,subs="attributes+"]
--
# Oracle settings
spring.datasource.url=jdbc:oracle:thin:@${SERVICE_DB_HOST}:1521/${SERVICE_DB_NAME}
spring.datasource.username=${SERVICE_DB_USER}
spring.datasource.password=${SERVICE_DB_PASSWORD}
spring.datasource.driver.class=oracle.jdbc.driver.OracleDriver
spring.datasource.platform=oracle

spring.jpa.properties.hibernate.hbm2ddl.import_files=import-oracle.sql
spring.jpa.database-platform=org.hibernate.dialect.Oracle12cDialect
spring.jpa.hibernate.ddl-auto=create
--
====

There are accordingly 3 different `import.sql` files, basically the motivation is the different way of refering to the next value of a database sequence.

[tabs]
====
import-h2.sql::
+
[.console-input]
[source,properties,subs="attributes+"]
--
insert into fruit (id, name) values (FRUIT_SEQ.NEXTVAL, 'Cherry');
insert into fruit (id, name) values (FRUIT_SEQ.NEXTVAL, 'Apple');
insert into fruit (id, name) values (FRUIT_SEQ.NEXTVAL, 'Banana');
--
import-postgresql.sql::
+
[.console-input]
[source,properties,subs="attributes+"]
--
insert into fruit (id, name) values ( nextval ('FRUIT_SEQ'), 'Cherry');
insert into fruit (id, name) values ( nextval ('FRUIT_SEQ'), 'Apple');
insert into fruit (id, name) values ( nextval ('FRUIT_SEQ'), 'Banana');
--
import-oracle.sql::
+
[.console-input]
[source,properties,subs="attributes+"]
--
insert into fruit (id, name) values (FRUIT_SEQ.NEXTVAL, 'Cherry');
insert into fruit (id, name) values (FRUIT_SEQ.NEXTVAL, 'Apple');
insert into fruit (id, name) values (FRUIT_SEQ.NEXTVAL, 'Banana');
--
====

[#run-local]
== Running the code locally against H2

One decision made for this example was to keep it as SQL-standard as possible so that we can move to different database as esasily as possible. I know, some times this is not possible or ideal... but it's ok for this example.

As we have said before in this guide you'll not have to code, instead we'll focus on running, testing, deploying, etc.

Let's get started and see if the code works locally and using H2.

[.console-input]
[source,bash,options="nowrap",subs="attributes+"]
----
mvn clean spring-boot:run -Dspring-boot.run.profiles=local -Plocal
----

You should get this output.

.TIPS
[TIP]
===============================
Pay attention to the profile in use => *The following profiles are active: `local`*. 

Also the `import.sql` file used => *Executing import script 'file:/Users/nostromo/.../import-h2.sql'*
===============================

[.console-output]
[source,bash,subs="attributes+"]
----
...
2021-01-28 INFO 59429 --- [  restartedMain] dev.snowdrop.example.ExampleApplication  : Starting ExampleApplication on nostromo with PID 59429 (/Users/nostromo/spring-boot-fruit-service/target/classes started by cvicensa in /Users/nostromo/spring-boot-fruit-service)
2021-01-28 INFO 59429 --- [  restartedMain] dev.snowdrop.example.ExampleApplication  : The following profiles are active: local
...
2021-01-28 INFO 59429 --- [  restartedMain] .s.d.r.c.RepositoryConfigurationDelegate : Bootstrapping Spring Data JPA repositories in DEFAULT mode.
2021-01-28 INFO 59429 --- [  restartedMain] .s.d.r.c.RepositoryConfigurationDelegate : Finished Spring Data repository scanning in 42ms. Found 1 JPA repository interfaces.
...
2021-01-28 INFO 59429 --- [  restartedMain] w.s.c.ServletWebServerApplicationContext : Root WebApplicationContext: initialization completed in 1352 ms
2021-01-28 INFO 59429 --- [  restartedMain] com.zaxxer.hikari.HikariDataSource       : HikariPool-1 - Starting...
2021-01-28 INFO 59429 --- [  restartedMain] com.zaxxer.hikari.HikariDataSource       : HikariPool-1 - Start completed.
2021-01-28 INFO 59429 --- [  restartedMain] o.s.b.a.h2.H2ConsoleAutoConfiguration    : H2 console available at '/h2-console'. Database available at 'jdbc:h2:mem:testdb'
2021-01-28 INFO 59429 --- [  restartedMain] o.hibernate.jpa.internal.util.LogHelper  : HHH000204: Processing PersistenceUnitInfo [name: default]
2021-01-28 INFO 59429 --- [  restartedMain] org.hibernate.Version                    : HHH000412: Hibernate ORM core version 5.4.21.Final
2021-01-28 INFO 59429 --- [  restartedMain] o.hibernate.annotations.common.Version   : HCANN000001: Hibernate Commons Annotations {5.1.0.Final}
2021-01-28 INFO 59429 --- [  restartedMain] org.hibernate.dialect.Dialect            : HHH000400: Using dialect: org.hibernate.dialect.H2Dialect
2021-01-28 INFO 59429 --- [  restartedMain] o.h.t.schema.internal.SchemaCreatorImpl  : HHH000476: Executing import script 'file:/Users/nostromo/spring-boot-fruit-service/target/classes/import-h2.sql'
2021-01-28 INFO 59429 --- [  restartedMain] o.h.e.t.j.p.i.JtaPlatformInitiator       : HHH000490: Using JtaPlatform implementation: [org.hibernate.engine.transaction.jta.platform.internal.NoJtaPlatform]
2021-01-28 INFO 59429 --- [  restartedMain] j.LocalContainerEntityManagerFactoryBean : Initialized JPA EntityManagerFactory for persistence unit 'default'
...
2021-01-28 INFO 59429 --- [  restartedMain] o.s.b.w.embedded.tomcat.TomcatWebServer  : Tomcat started on port(s): 8080 (http) with context path ''
2021-01-28 INFO 59429 --- [  restartedMain] dev.snowdrop.example.ExampleApplication  : Started ExampleApplication in 3.632 seconds (JVM running for 4.2)
----

Now open a browser and point to link:http://localhost:8080:[http://localhost:8080]

You should see this:

TIP: You can edit, save, delete to test the functionalities implemented by `FruitController`

image::fruit-service-h2-display.png[Fruit Service on H2]

[#deploy-database]
== Deploying PostgreSQL on OCP

WARNING: Before proceeding log in your cluster using `oc login` with a normal user no need for special permissions.

In order to run our application, we need a namespace, let's create one:

[.console-input]
[source,bash,options="nowrap",subs="attributes+"]
----
export PROJECT_NAME={artifact_id}-dev
oc new-project $\{PROJECT_NAME}
----

In order for the application to work properly we'll first deploy a `PostgreSQL` database, then the code, to do so run this commands:

[.console-input]
[source,bash,options="nowrap",subs="attributes+"]
----
oc new-app -e POSTGRESQL_USER=luke -e POSTGRESQL_PASSWORD=secret -e POSTGRESQL_DATABASE=FRUITSDB \
  centos/postgresql-10-centos7 --as-deployment-config=true --name=postgresql-db -n $\{PROJECT_NAME}
----

Now let's label the deployment so that it look better in the web console:

[.console-input]
[source,bash,options="nowrap",subs="attributes+"]
----
oc label dc/postgresql-db app.kubernetes.io/part-of=fruit-service-app -n $\{PROJECT_NAME} && \
  oc label dc/postgresql-db app.openshift.io/runtime=postgresql --overwrite=true -n $\{PROJECT_NAME} 
----

Check the database is running:

[.console-input]
[source,bash,options="nowrap",subs="attributes+"]
----
oc get pod -n ${PROJECT_NAME}
----

You should see something like this:
[.console-output]
[source,bash,options="nowrap",subs="attributes+"]
----
NAME                        READY   STATUS      RESTARTS   AGE
postgresql-db-1-deploy      0/1     Completed   0          2d6h
postgresql-db-1-n585q       1/1     Running     0          2d6h
----

[TIP]
===============================
You can also run this command to check the name of the POD:
[.console-input]
[source,bash,options="nowrap",subs="attributes+"]
----
oc get pods -n $\{PROJECT_NAME} -o json | jq -r '.items[] | select(.status.phase | test("Running")) | select(.metadata.name | test("postgresql-db")).metadata.name'
----
===============================

[#deploy-code]
== Deploying the code on OCP

[.console-input]
[source,bash,options="nowrap",subs="attributes+"]
----
mvn clean oc:deploy -Popenshift-postgresql
----

Move to the OpenShift web console and from `Topology` in the `Developer` perspective click on the route link as in the picture.

image::fruit-service-postgresql-topology.png[Fruit Service on PostgreSQL Topology]

You should see this.

image::fruit-service-postgresql-display.png[Fruit Service on PostgreSQL Topology]

[#run-local-telepresence]
== Running locally against PostgreSQL with `telepresence`

.Permissions needed
[IMPORTANT]
===============================
This needs to be run by a `cluster-admin`

[.console-input]
[source,bash,options="nowrap",subs="verbatim,attributes+"]
----
oc adm policy add-scc-to-user privileged -z default -n ${PROJECT_NAME}
oc adm policy add-scc-to-user anyuid -z default -n ${PROJECT_NAME}
----
===============================

NOTE: Telepresence will modify the network so that Services in Kubernetes are reachable from your laptop and viceversa. 

The next command will result in the deployment for our application being scaled down to zero and the network altered so that traffic to it ends up in your laptop in port `8080`.

IMPORTANT: You'll be asked for `sudo` password, this is normal, telepresence needs to be able to modify networking rules so that you can see Kubernetes Services as local.

[.console-input]
[source,bash,options="nowrap",subs="attributes+"]
----
export TELEPRESENCE_USE_OCP_IMAGE=NO
oc project ${PROJECT_NAME}
telepresence --swap-deployment {artifact_id} --expose 8080
----

Evetually you'll se something like this:

[.console-output]
[source,bash,options="nowrap",subs="attributes+"]
----
...
T: Forwarding remote port 9779 to local port 9779.
T: Forwarding remote port 8080 to local port 8080.
T: Forwarding remote port 8778 to local port 8778.

T: Guessing that Services IP range is ['172.30.0.0/16']. Services started after this point will be inaccessible if are outside this range; restart telepresence 
T: if you can't access a new Service.
T: Connected. Flushing DNS cache.
T: Setup complete. Launching your command.

The default interactive shell is now zsh.
To update your account to use zsh, please run `chsh -s /bin/zsh`.
For more details, please visit https://support.apple.com/kb/HT208050.
@fruits-postgresql-dev/api-cluster-5555-5555-acme-com:6443/user1|bash-3.2$
----

[TIP]
===============================
Run from another terminal:
[.console-input]
[source,bash,options="nowrap",subs="attributes+"]
----
curl http://postgresql-db:5432
----

You should receive which looks bad but it's actually good, this means that the DNS Service name local to Kubernetes can be resolved from your computer and that the port `5432` has been reached!
[.console-output]
[source,bash,options="nowrap",subs="attributes+"]
----
curl: (52) Empty reply from server` 
----
===============================

Now from another terminal:
[.console-input]
[source,bash,options="nowrap",subs="attributes+"]
----
export PROJECT_NAME={artifact_id}-dev
SERVICE_DB_USER=luke SERVICE_DB_PASSWORD=secret SERVICE_DB_NAME=FRUITSDB SERVICE_DB_HOST=postgresql-db \
  mvn clean spring-boot:run -Dspring-boot.run.profiles=openshift-postgresql -Popenshift-postgresql
----

Now open a browser and point to link:http://localhost:8080:[http://localhost:8080]

You should see this:

TIP: You can edit, save, delete to test the functionalities implemented by `FruitController`

image::fruit-service-postgresql-display.png[Fruit Service on PostgreSQL]

[#binary-deploy]
== Binary deploy S2I

TODO
